use crate::scanner::tok::Tok;
use crate::sym::{SymExpr, Sum};

#[derive(Debug, Clone)]
pub enum Expr {
    Literal(Tok),
    Arr(Vec<Expr>),
    Group(Box<Expr>),
    Binary(Binary),
    Concat(Concat),
    Negate(Negate),
    Call(Call),
    Exp(Exp),
    Comp(Comp),
    Or(Or),
    And(And),
    Index(Index),
}

impl Expr {
    pub fn to_string(&self) -> String {
        use Expr::*;
        match self {
            Literal(l) => l.lexeme.clone(),
            Group(e) => format!("({})", (*e).to_string()),
            Binary(b) => {
                b.operands
                    .iter().enumerate()
                    .filter(|(i, _)| *i != 0)
                    .fold(b.operands.first().unwrap().to_string(), |acc, (i, v)| {
                        format!("{} {} {}", acc, b.operators[i - 1].lexeme, v.to_string())
                    })
            },
            Concat(c) => format!("{} {} {}", c.l.to_string(), c.op.lexeme, c.r.to_string()),
            Negate(n) => format!("-{}", n.value.to_string()),
            Call(c) => {
                let args = c.args
                    .iter()
                    .map(|arg| arg.to_string())
                    .collect::<Vec<_>>()
                    .join(", ");
                format!("{}({})", c.identifier.lexeme, args)
            }
            Exp(e) => format!("{}^{}", e.base.to_string(), e.power.to_string()),
            Comp(c) => {
                c.operands
                    .iter().enumerate()
                    .filter(|(i, _)| *i != 0)
                    .fold(c.operands.first().unwrap().to_string(), |acc, (i, v)| {
                        format!("{} {} {}", acc, c.operators[i - 1].lexeme, v.to_string())
                    })
            }
            And(a) => format!("{} and {}", a.right.to_string(), a.left.to_string()),
            Or(o) => format!("{} or {}", o.right.to_string(), o.left.to_string()),
            Arr(a) => format!("[{}]", a.iter().map(|a| a.to_string()).collect::<Vec<_>>().join(", ")),
            Index(i) => i.expr.to_string() + &i.index.to_string(),
        }
    }
    pub fn kind_name(&self) -> String {
        match self {
Expr::Literal(_) => String::from("literal"),
Expr::Arr(_) => String::from("array"),
Expr::Group(_) => String::from("group"),
// Binary(_) => String::from("binary"),
Expr::Concat(_) => String::from("string concatenation"),
Expr::Negate(_) => String::from("negation"),
Expr::Call(_) => String::from("call"),
Expr::Exp(_) => String::from("exponent"),
Expr::Comp(_) => String::from("(in)equality"),
Expr::Or(_) => String::from("logical or"),
Expr::And(_) => String::from("logical and"),
Expr::Index(_) => String::from("index"),
        }
    }
    pub fn to_sym(&self) -> Result<SymExpr, String> {
        use crate::scanner::tok::TokType;

        match self {
            Expr::Literal(tok) => match tok.t {
                TokType::Int => Ok(SymExpr::z_from_string(&tok.lexeme)),
                TokType::Float => todo!(), // TODO Convert to Q
                TokType::Identifier => Ok(SymExpr::Symbol(tok.lexeme.clone())), // TODO symbol
                _ => todo!(), // TODO: Print error message
            }
            Expr::Binary(b) => b.to_sym(),
            _ => Err(String::from("Expected a symbolic expression.")) // TODO think of better eror message
 // TODO
        }
    }
}

#[derive(Debug, Clone)]
pub struct Exp {
    pub base: Box<Expr>,
    pub power: Box<Expr>,
    pub op: Tok,
}

#[derive(Debug, Clone)]
pub struct Binary {
    pub operators: Vec<Tok>,
    pub operands: Vec<Expr>,
}

impl Binary {
    pub fn new(operators: Vec<Tok>, operands: Vec<Expr>) -> Self {
        Self { operators, operands }
    }
    pub fn sum_to_sym(&self) -> Result<SymExpr, String> {
        let mut exprs = Vec::new();
        for operand in self.operands.iter() {
            exprs.push(operand.to_sym()?); 
        }
        Ok(SymExpr::Sum(Sum { exprs }))
    }
    pub fn to_sym(&self) -> Result<SymExpr, String> {
        use crate::scanner::tok::TokType;
        let opt = self.operators[0].t;
        match opt {
            TokType::Plus => self.sum_to_sym(),
            _ => todo!(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct Negate {
    pub minus: Tok,
    pub value: Box<Expr>
}

#[derive(Debug, Clone)]
pub struct Concat {
    pub l: Box<Expr>,
    pub op: Tok,
    pub r: Box<Expr>,
}

#[derive(Debug, Clone)]
pub struct Call {
    pub identifier: Tok,
    pub args: Vec<Expr>,
    pub rparen: Tok,
}

#[derive(Debug, Clone)]
pub struct Comp {
    pub operators: Vec<Tok>,
    pub operands: Vec<Expr>,
}

#[derive(Debug, Clone)]
pub struct Or {
    pub op: Tok,
    pub left: Box<Expr>,
    pub right: Box<Expr>,
}

#[derive(Debug, Clone)]
pub struct And {
    pub op: Tok,
    pub left: Box<Expr>,
    pub right: Box<Expr>,
}

#[derive(Debug, Clone)]
pub struct Index {
    pub expr: Box<Expr>,
    pub lb: Tok,
    pub index: Box<Expr>,
    pub rb: Tok,
}

